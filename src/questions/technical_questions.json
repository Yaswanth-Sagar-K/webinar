{
  "testName": "Technical Test",
  "duration": "30 mins",
  "numberOfQuestions": 30,
  "topicsCovered": [
    "Advanced Programming & Algorithms"
  ],
  "questions": [
    {
      "id": 1,
      "question": "What is the time complexity of finding an element in a balanced binary search tree?",
      "options": [
        "O(log n)",
        "O(n)",
        "O(n log n)",
        "O(1)"
      ],
      "answer": "O(log n)"
    },
    {
      "id": 2,
      "question": "Which algorithmic pattern is used in quicksort?",
      "options": [
        "Divide and Conquer",
        "Dynamic Programming",
        "Greedy",
        "Backtracking"
      ],
      "answer": "Divide and Conquer"
    },
    {
      "id": 3,
      "question": "Given this code, what’s the output?\n```\ndef fib(n, memo={}):\n    if n in memo: return memo[n]\n    if n < 2: return n\n    memo[n] = fib(n-1, memo) + fib(n-2, memo)\n    return memo[n]\nprint(fib(35))\n```",
      "options": [
        "9227465",
        "3524578",
        "14930352",
        "5702887"
      ],
      "answer": "9227465"
    },
    {
      "id": 4,
      "question": "What is the space complexity of Depth-First Search (recursive)?",
      "options": [
        "O(h)",
        "O(n)",
        "O(log n)",
        "O(n²)"
      ],
      "answer": "O(h)"
    },
    {
      "id": 5,
      "question": "Complete the pseudo-code for binary search on sorted array `A`:\n```\nlow = 0; high = len(A)-1\nwhile low <= high:\n    mid = (low + high) // 2\n    if A[mid] == target:\n        return mid\n    elif A[mid] < target:\n        low = mid + 1\n    else:\n        high = mid - 1\nreturn _______\n```",
      "options": [
        "-1",
        "None",
        "0",
        "high"
      ],
      "answer": "-1"
    },
    {
      "id": 6,
      "question": "In hash tables, to reduce collisions, which approach resizes the table and rehashes elements?",
      "options": [
        "Rehashing",
        "Chaining",
        "Open addressing",
        "Linear probing"
      ],
      "answer": "Rehashing"
    },
    {
      "id": 7,
      "question": "Which data structure uses LRU (Least Recently Used) eviction policy?",
      "options": [
        "Stack",
        "Queue",
        "Cache (like ordered dict)",
        "Heap"
      ],
      "answer": "Cache (like ordered dict)"
    },
    {
      "id": 8,
      "question": "What will the following Python code print?\n```\nfrom collections import deque\nq = deque([1,2,3])\nq.appendleft(0)\nq.pop()\nprint(list(q))\n```",
      "options": [
        "[0,1,2]",
        "[1,2,3]",
        "[0,1,2,3]",
        "[2,3]"
      ],
      "answer": "[0,1,2]"
    },
    {
      "id": 9,
      "question": "Which sorting algorithm is stable?",
      "options": [
        "Quicksort",
        "Heapsort",
        "Merge Sort",
        "Selection Sort"
      ],
      "answer": "Merge Sort"
    },
    {
      "id": 10,
      "question": "What does `memo` stand for in programming?",
      "options": [
        "Memorandum",
        "Memoization",
        "Memory",
        "Memoir"
      ],
      "answer": "Memoization"
    },
    {
      "id": 11,
      "question": "Which data structure supports fast prefix searches?",
      "options": [
        "Trie",
        "Hash Table",
        "Stack",
        "Graph"
      ],
      "answer": "Trie"
    },
    {
      "id": 12,
      "question": "What’s the output?\n```\na = [1,2,3]; b = a; a += [4]\nprint(b)\n```",
      "options": [
        "[1,2,3,4]",
        "[1,2,3]",
        "Error",
        "[4]"
      ],
      "answer": "[1,2,3,4]"
    },
    {
      "id": 13,
      "question": "Which programming paradigm does Python support?",
      "options": [
        "Procedural",
        "Object-oriented",
        "Functional",
        "All of the above"
      ],
      "answer": "All of the above"
    },
    {
      "id": 14,
      "question": "What’s the time complexity of building a heap from unsorted array?",
      "options": [
        "O(n)",
        "O(n log n)",
        "O(log n)",
        "O(n²)"
      ],
      "answer": "O(n)"
    },
    {
      "id": 15,
      "question": "What is tail recursion?",
      "options": [
        "Recursion where the recursive call is the last operation",
        "Recursion with two calls",
        "Recursion using global variables",
        "Recursion that never terminates"
      ],
      "answer": "Recursion where the recursive call is the last operation"
    },
    {
      "id": 16,
      "question": "What’s the output?\n```\ndef foo(lst):\n    return [x*2 for x in lst if x%2]\nprint(foo([1,2,3,4,5]))\n```",
      "options": [
        "[2,6,10]",
        "[2,4,6,8,10]",
        "[1,3,5]",
        "[4,8]"
      ],
      "answer": "[2,6,10]"
    },
    {
      "id": 17,
      "question": "In dynamic programming, what’s overlapping subproblem condition?",
      "options": [
        "Same subproblems are solved multiple times",
        "Problems use same memory",
        "Problems run in parallel",
        "Problems sorted recursively"
      ],
      "answer": "Same subproblems are solved multiple times"
    },
    {
      "id": 18,
      "question": "What will this code print?\n```\nset1 = {1,2,3}\nset2 = {3,4,5}\nprint(set1 & set2)\n```",
      "options": [
        "{3}",
        "{1,2,3,4,5}",
        "Error",
        "{}"
      ],
      "answer": "{3}"
    },
    {
      "id": 19,
      "question": "Which of these is NP-hard (not proven P)?",
      "options": [
        "Travelling Salesman Problem",
        "Binary Search",
        "Heap Insertion",
        "Merge Sort"
      ],
      "answer": "Travelling Salesman Problem"
    },
    {
      "id": 20,
      "question": "What’s the result of this snippet?\n```\nfor i in reversed(range(3)):\n    print(i)\n```",
      "options": [
        "2 1 0",
        "0 1 2",
        "3 2 1",
        "Error"
      ],
      "answer": "2 1 0"
    },
    {
      "id": 21,
      "question": "Which structure is optimal for LCA (Lowest Common Ancestor) queries on trees?",
      "options": [
        "Segment Tree",
        "Sparse Table",
        "Hash Table",
        "Heap"
      ],
      "answer": "Sparse Table"
    },
    {
      "id": 22,
      "question": "What is the amortized cost of Python’s list `.append()`?",
      "options": [
        "O(1)",
        "O(log n)",
        "O(n)",
        "O(n log n)"
      ],
      "answer": "O(1)"
    },
    {
      "id": 23,
      "question": "What’s the worst-case time complexity of quickselect?",
      "options": [
        "O(n²)",
        "O(n log n)",
        "O(n)",
        "O(log n)"
      ],
      "answer": "O(n²)"
    },
    {
      "id": 24,
      "question": "What’s output?\n```\ndef merge(a,b):\n    return sorted(a+b)\nprint(merge([3,1],[2,4]))\n```",
      "options": [
        "[1,2,3,4]",
        "[3,1,2,4]",
        "[4,3,2,1]",
        "Error"
      ],
      "answer": "[1,2,3,4]"
    },
    {
      "id": 25,
      "question": "Which data structure allows constant-time FIFO operations?",
      "options": [
        "Linked List",
        "Deque",
        "Binary Heap",
        "BST"
      ],
      "answer": "Deque"
    },
    {
      "id": 26,
      "question": "What does the 'Greedy Choice Property' ensure?",
      "options": [
        "Local optimum leads to global optimum",
        "Problems are NP-hard",
        "Requires DP",
        "Runs in O(n²)"
      ],
      "answer": "Local optimum leads to global optimum"
    },
    {
      "id": 27,
      "question": "What is a Python generator?",
      "options": [
        "Function using `yield` to produce values lazily",
        "Comprehension of lists",
        "Thread-safe iterator",
        "Function that returns tuple"
      ],
      "answer": "Function using `yield` to produce values lazily"
    },
    {
      "id": 28,
      "question": "What is the output?\n```\nprint({i: i*i for i in range(3)})\n```",
      "options": [
        "{0:0,1:1,2:4}",
        "{0,1,4}",
        "[(0,0),(1,1),(2,4)]",
        "Error"
      ],
      "answer": "{0:0,1:1,2:4}"
    },
    {
      "id": 29,
      "question": "Which algorithm finds the shortest path in weighted graphs?",
      "options": [
        "Dijkstra’s algorithm",
        "BFS",
        "Merge Sort",
        "Prim’s algorithm"
      ],
      "answer": "Dijkstra’s algorithm"
    },
    {
      "id": 30,
      "question": "Which technique avoids redundant work by storing intermediate results?",
      "options": [
        "Memoization",
        "Brute force",
        "Backtracking",
        "Greedy"
      ],
      "answer": "Memoization"
    }
  ]
}